# 메모리와 포인터

## 컴퓨터와 메모리

**변수의 본질은 메모리**이며 모든 메모리는 자신의 위치를 **식별하기 위한 근거로 고유번호(일련번호)**를 갖는데, 이 번호를 **메모리 주소**라 합니다. 따라서 변수의 선언 및 정의는 메모리 확보를 의미하며, 선언 시 부여한 이름으로 확보한 메모리를 식별합니다.

변수를 이루는 세가지 요소는 다음과 같습니다. (예: `char ch = 'A';`)

1. 이름이 부여된 메모리 (`ch`, 식별자)
2. 그 안에 담긴 정보 (`'A'`)
3. 메모리의 주소 (`&ch`)

```c
#include <stdio.h>

int main(void)
{
    int nData = 10;
    printf("%d\n", nData);
    printf("%p\n", &nData);

    return 0;
}
```
`nData`를 대상으로 단항 연산인 주소 번지 연산(주소 연산)을 수행하여 그 결과를 메모리의 주소 형식(`%p`)으로 출력한 것입니다.

### 1. 메모리의 종류

메모리도 그 용도에 따라 스택(stack), 힙(heap), 데이터 영역(data section), 텍스트 영역(text section) 등으로 나뉩니다.

- Stack: 자동변수이고 지역변수인 변수가 사용하는 메모리 영역이며, 임시 메모리의 성격을 가진다. 크기가 작고 관리(할당 및 반환)가 자동으로 이루어지는 장점이 있다.
- Heap: **동적 할당할 수 있는 자유 메모리 영역**이며, 개발자 자신 스스로 직접 관리해야 한다. 대량의 메모리가 필요하거나 메모리의 크기를 미리 알 수 없을 때 사용한다.
- PE image (실행파일)
    - Text section: C 언어의 소스코드가 번역된 기계어가 저장된 메모리 영역이며, 기본적으로 읽기전용 메모리이다.
    - Data section
        - Read only: 상수 형태로 기술하는 문자열(예: "Hello")이 저장된 메모리 영역이며, Text 처럼 읽기는 가능하나 쓰기는 허용되지 않는다.
        - Read/Write: 정적변수나 전역변수들이 사용하는 메모리 영역이며, 별도로 초기화 하지 않아도 0으로 초기화 된다. 관리는 자동이다.

### 2. 포인터 변수의 선언 및 정의

포인터 변수는 **메모리의 주소를 저장하기 위한 전용 변수**입니다.

`nData`라는 이름이 부여된 변수(메모리)에 분명히 주소가 있지만 굳이 그것을 꼭 알아야 할 필요는 없습니다. 하지만 직접 메모리를 다루어야 할 경우도 있습니다. 메모리 주소를 알아내는 방법이 바로 단항 연산자인 주소 연산자를 사용한는 것입니다.

그리고 주소 연산과 정반대되는 개념의 연산자는 바로 '간접지정 연산자(`*`)'입니다. '지정'이라는 말은 임의 대상 메모리에 대한 길이와 해석방법(자료형)을 지정한다는 뜻입니다.

```c
#include <stdio.h>

int main(void)
{
    int x = 10;
    int *pnData = &x;   // int 형식에 대한 포인터 변수 선언 및 정의

    printf("%d\n", x);
    *pnData = 20;
    printf("%d\n", x);
    return 0;
}
```
`*pnData` 코드의 의미는 "포인터 변수 pnData에 저장된 주소를 가진 메모리를 int형 변수로 취급"한다는 뜻입니다.

### 3. 포인터와 배열

## 메모리 동적 할당 및 관리

### 1. 메모리 초기화 및 사용(배열)

### 2. 메모리 복사

### 3. 메모리 비교(`memcmp()`, `strcmp()`)

### 4. 문자열 검색

### 5. 배열 연산자 풀어쓰기

### 6. `realloc()`, `sprintf()` 함수

## 잘못된 메모리 접근

## 포인터의 배열과 다중 포인터

### 1. `char*`의 배열

### 2. 다중 포인터

### 3. 다차원 배열에 대한 포인터

## 변수와 메모리

### 1. 정적변수 `static`

### 2. 레지스터 변수 `register`
