# 메모리와 포인터

## 컴퓨터와 메모리

**변수의 본질은 메모리**이며 모든 메모리는 자신의 위치를 **식별하기 위한 근거로 고유번호(일련번호)**를 갖는데, 이 번호를 **메모리 주소**라 합니다. 따라서 변수의 선언 및 정의는 메모리 확보를 의미하며, 선언 시 부여한 이름으로 확보한 메모리를 식별합니다.

변수를 이루는 세가지 요소는 다음과 같습니다. (예: `char ch = 'A';`)

1. 이름이 부여된 메모리 (`ch`, 식별자)
2. 그 안에 담긴 정보 (`'A'`)
3. 메모리의 주소 (`&ch`)

```c
#include <stdio.h>

int main(void)
{
    int nData = 10;
    printf("%d\n", nData);
    printf("%p\n", &nData);

    return 0;
}
```
`nData`를 대상으로 단항 연산인 주소 번지 연산(주소 연산)을 수행하여 그 결과를 메모리의 주소 형식(`%p`)으로 출력한 것입니다.

### 1. 메모리의 종류

메모리도 그 용도에 따라 스택(stack), 힙(heap), 데이터 영역(data section), 텍스트 영역(text section) 등으로 나뉩니다.

- Stack: 자동변수이고 지역변수인 변수가 사용하는 메모리 영역이며, 임시 메모리의 성격을 가진다. 크기가 작고 관리(할당 및 반환)가 자동으로 이루어지는 장점이 있다.
- Heap: **동적 할당할 수 있는 자유 메모리 영역**이며, 개발자 자신 스스로 직접 관리해야 한다. 대량의 메모리가 필요하거나 메모리의 크기를 미리 알 수 없을 때 사용한다.
- PE image (실행파일)
    - Text section: C 언어의 소스코드가 번역된 기계어가 저장된 메모리 영역이며, 기본적으로 읽기전용 메모리이다.
    - Data section
        - Read only: 상수 형태로 기술하는 문자열(예: "Hello")이 저장된 메모리 영역이며, Text 처럼 읽기는 가능하나 쓰기는 허용되지 않는다.
        - Read/Write: 정적변수나 전역변수들이 사용하는 메모리 영역이며, 별도로 초기화 하지 않아도 0으로 초기화 된다. 관리는 자동이다.

### 2. 포인터 변수의 선언 및 정의

포인터 변수는 **메모리의 주소를 저장하기 위한 전용 변수**입니다.

`nData`라는 이름이 부여된 변수(메모리)에 분명히 주소가 있지만 굳이 그것을 꼭 알아야 할 필요는 없습니다. 하지만 직접 메모리를 다루어야 할 경우도 있습니다. 메모리 주소를 알아내는 방법이 바로 단항 연산자인 주소 연산자를 사용한는 것입니다.

그리고 주소 연산과 정반대되는 개념의 연산자는 바로 '간접지정 연산자(`*`)'입니다. '지정'이라는 말은 임의 대상 메모리에 대한 길이와 해석방법(자료형)을 지정한다는 뜻입니다.

```c
#include <stdio.h>

int main(void)
{
    int x = 10;
    int *pnData = &x;   // int 형식에 대한 포인터 변수 선언 및 정의

    printf("%d\n", x);
    *pnData = 20;
    printf("%d\n", x);
    return 0;
}
```
`*pnData` 코드의 의미는 "포인터 변수 pnData에 저장된 주소를 가진 메모리를 int형 변수로 취급"한다는 뜻입니다.

### 3. 포인터와 배열

배열의 이름은 0번 요소의 주소이며, 전체 배열을 대표하는 식별자입니다. 즉, `int`형 포인터에 `int`형 변수의 주소뿐만 아니라, `int`형 배열의 이름도 담을 수 있습니다.

```c
#include <stdio.h>

int main(void)
{
    int aList[5] = {0};
    int *pnData = aList;

    printf("aList[0]: %d\n", aList[0]);
    *pnData = 20;
    printf("aList[0] : %d\n", aList[0]);
    return 0;
}
```
`int *pnData = aList`를 `int *pnData = &aList[0];`라고 수정해도 의미는 같습니다. 어차피 배열의 이름은 0번 요소의 주소에 부여한 식별자입니다.

그리고 `*pnData = 20;` 코드의 '간접지정 연산자'는 단항연산자이며, 사실 이 연산은 `*(pnData + 0)`을 의미합니다. 포인터 변수 `pnData`에 저장된 주소를 기준으로 오른쪽으로 `int` 0개 떨어진 위치(주소)의 메모리를 `int`형 변수로 지정한다는 것입니다.

그리고 `*(pnData + 0)`를 다른 코드로 표시하면 `pnData[0]`입니다. 배열과 포인터가 문법상 호환되는 이유는 개념적으로나 기술적으로나 사실상 같기 때문입니다. 단지 차이가 있다면 포인터 변수는 말 그대로 변수이고, 배열의 이름은 '주소상수'라는 것뿐입니다.

```c
#include <stdio.h>

int main(void)
{
    char szBuffer[16] = {"Hello"};
    char *pszData = szBuffer;
    int nLength = 0;

    while (*pszData != '\0')
    {
        pszData++;  // 포인터 한 칸 이동
        nLength++;
    }

    printf("Length: %d\n", nLength);
    printf("Length: %d\n", strlen(szBuffer));
    printf("Length: %d\n", strlen("World"));
    return 0;
}
```
위의 예제는 포인터 변수에 저장된 주소값을 계속 증가시키는 방법으로 배열의 처음부터 `\0`이 저장된 메모리가 나올 때까지 차례로 접근합니다. `pszData++` 단항 연산으로 오른쪽으로 `char`형 크기만큼 한 칸 이동(주소 증가)합니다.

```c
#include <stdio.h>

int main(void)
{
    char szBuffer[16] = {"Hello"};
    char *pszData = szBuffer;
    int nLength = 0;

    while (*pszData != '\0')
        pszData++;

    printf("Length: %d\n", pszData - szBuffer);
    return 0;
}
```
위의 예제는 주소 차이를 이용해 문자열의 길이를 측정하는 예를 보인 것입니다.

## 메모리 동적 할당 및 관리

`malloc()`과 `free()` 함수는 메모리를 동적으로 할당 및 해제하는 함수입니다. `malloc()` 함수를 이용하면 자동변수로 사용할 수 있는 메모리와는 비교할 수도 없을 만큼 큰 메모리를 자유롭게 다룰 수 있습니다. 게다가 '동적(dynamic, runtime)'으로 할 수 있습니다. 대신 반환(혹은 해제)의 책임이 따릅니다.

```c
void *malloc(size_t size);
```
- 인자: 할당받을 메모리의 바이트 단위 크기
- 반환값: 힙 영역에 할당된 메모리 덩어리 중 첫 번째 바이트 메모리의 주소
- 설명: 할당받은 메모리는 반드시 `free()` 함수를 이용하여 반환해야 하며, 메모리를 초기화하려면 `memset()` 함수를 이용해야 한다. 기본적으로는 쓰레기 값이 들어 있다.

### 1. 메모리 초기화 및 사용(배열)

### 2. 메모리 복사

### 3. 메모리 비교(`memcmp()`, `strcmp()`)

### 4. 문자열 검색

### 5. 배열 연산자 풀어쓰기

### 6. `realloc()`, `sprintf()` 함수

## 잘못된 메모리 접근

## 포인터의 배열과 다중 포인터

### 1. `char*`의 배열

### 2. 다중 포인터

### 3. 다차원 배열에 대한 포인터

## 변수와 메모리

### 1. 정적변수 `static`

### 2. 레지스터 변수 `register`
