# 연산자 - 기본

자료형, 변수의 선언 및 정의, 기본 입출력 등은 메모리 사용과 관련된 이론들이었습니다. 그러나 연산자(operator)는 메모리가 아니라 CPU 연산과 직결되는 문법입니다.

`3 + 4`라는 연산식을 이루는 전체 항(item)의 개수는 3개입니다. 여기서 연산 항인 `+` 기호를 제외하고, 피연산자 항의 개수만 생각하면 2항이 됩니다. 그러므로 덧셈 연산자(`+`)를 2항 연산자라고 부릅니다. 참고로 C 언어의 연산자에는 피연산자의 개수가 1개인 단항 연산자에서 최대 3항 연산자(조건 연산자)까지 있습니다.

## 산술 연산자

우리가 기본적으로 알고 있는 수학에 대한 상식을 C 언어로 그대로 옮긴 문법입니다. 덧셈 `+`, 뺄셈 `-`, 곱셈 `*`, 나눗셈 `/`, 나머지 연산 `%`로 표시합니다.

### 1. 덧셈, 뺄셈 연산자

연산을 통해 얻은 결과는 **임시결과**입니다. 연산이 더 없다면, 마지막 임시결과가 최종 결과입니다. 주의할 점은 임시결과는 또 다른 임시결과를 얻는 과정에서 유실된다는 사실입니다. 연산의 최종 결과 역시 임시결과이므로 필요하다면 유실전에 저장합니다.

### 2. 이형자료 간의 연산 및 형승격

이형자료 간의 연산이 문법적으로 전혀 하자가 없는 경우, 임시결과의 자료형은 연산에 참여한 피연사자 중 **정보 표현범위가 더 넓은 자료형**이 됩니다. 이처럼 연산의 결과가 피연산자의 자료형보다 표현범위가 넓은 형식으로 변경되는 현상을 **형승격(type promotion)**이라고 합니다.

```c
#include <stdio.h>

int main(void)
{
    char ch = 'A';

    // char를 %c로 출력
    printf("%c\n", ch);

    // 'char + int'는 int 형식
    printf("%c\n", ch + 1);
    printf("%c\n", 'A' + 2);

    // 'double + int'는 double 형식
    // 따라서 %d 형식으로 출력할 수 없다.
    printf("%d\n", 5.0 + 2);
    printf("%f\n", 5.0 + 2);
    return 0;
}
```

[실습문제](../code/04/01.c)

### 3. 곱셉, 나눗셈 연산자

나눗셈 연산은 다음과 같은 두 가지 원칙을 추가로 알아야 합니다.

- 정수를 정수로 나눈 결과는 정수
- 절대 0으로 나눌수 없음

### 4. 나머지 연산자

나머지 연산자도 나누기 연산자와 마찬가지로 0으로 나눈 나머지를 구할 수 없습니다. 더불어 한 가지 더 알아야 할 사실은 나머지 연산자의 피연산자로 실수가 사용될 수 없다는 점입니다. 그리고 나머지 연산자의 우선순위는 곱셈, 나눗셈 연산자와 같습니다. 따라서 덧셈이나 뺄셈보다 우선합니다.

프로그래머 입장에서 나머지 연산자는 연산자 그 이상의 의미를 갖습니다. 나머지 연산 결과는 제수보다 클 수 없기 때문입니다. 따라서 **나머지 연산은 제수만큼 경우의 수**를 갖습니다. 이를 이용하면 일정 범위로 경우의 수를 강제할 수 있기 때문에 중요한 의미가 있습니다.

[실습문제](../code/04/02.c)

## 대입 연산자

### 1. 단순 대입 연산자

오로지 대입(복사)만 이루어집니다. 대입 연산자의 왼쪽 피연산자를 l-value라 하고 오른쪽 피연산자를 r-value라 합니다. l-value는 left 외에 **locator**(위치 지정자)라는 의미도 됩니다. 즉, 정보를 다음을 수 있는 **변수**를 말하는 것입니다.

```c
#include <stdio.h>

int main(void)
{
    char szBuffer[32] = {0};

    // 상수에 대입 연산을 수행할 수 없다.
    3 = 4;
    // 배열의 이름은 '주소 상수'다. 변수가 아니다.
    szBuffer = 'A';

    return 0;
}
```

#### 프로그래밍 기본요소: 교환

```c
#include <stdio.h>

int main(void)
{
    // nTmp는 '교환'을 위해 필요한 변수
    int x = 10, y = 20, nTmp = 0;
    printf("Before: %d, %d\n", x, y);

    // 두 변수 x와 y에 저장된 값을 서로 교환
    nTmp = x;
    x = y;
    y = nTmp;

    printf("After: %d, %d\n", x, y);
    return 0;
}
```

### 2. 복합 대입 연산자

기존의 단순 대입 연산자에 '산술 연산자'나 '비트 연산자'를 조합하여 새로운 하나의 연산자로 만든 것입니다. 실제로 연산도 두번 합니다. 우선순위는 매우 낮은 편에 속합니다.

#### 프로그래밍 기본 요소: 누적

```c
#include <stdio.h>

int main(void)
{
    int nInput, nTotal = 0;

    scanf("%d", &nInput);
    nTotal += nInput;
    scanf("%d", &nInput);
    nTotal += nInput;
    scanf("%d", &nInput);
    nTotal += nInput;

    printf("Total: %d\n", nTotal);
    return 0;
}
```

누적의 대상이 되는 변수는 누적 연산에 앞서 반드시 `0`으로 **초기화** 해야 한다는 사실에 주의합니다.

## 형변환 연산자

형변환(type cast) 연산자는 단항 연산자입니다. 우선순위가 높은 연산입니다. 그리고 형변환 연산자에는 늘 '강제'라는 수식어가 따라 다닙니다. 이유는 문제가 생기든 말든, 적절하든 그렇지 않든 무조건 변환하기 때문입니다.

## 단항 증감 연산자

`++`와 `--`로 표시되는 연산자입니다. 피연산자에 저장된 정보를 1씩 증가(감소)시킨다는 의미입니다. 기본 전제는 피연산자가 l-value라는 점입니다.

#### 프로그래밍 기본요소 : 계수

```c
#include <stdio.h>

int main(void)
{
    int x = 10;

    // 1. x에 저장된 값과 1을 더해 다시 x에 저장
    x = x + 1;
    printf("%d\n", x);

    // 2. x에 저장되어 있는 값에 1을 누산
    x += 1;
    printf("%d\n", x);

    // 3. x에 저장된 값을 1 증가
    ++x;
    printf("%d\n", x);
    return 0;
}
```

결과적으로 보면 `++x`는 x에 1을 누적하는 연산이 맞습니다. 그런데 이때는 누적이라는 표현보다는 **계수(counting)**라는 표현이 더 어울립니다. 계수 역시 누적에 기반을 두므로 계수기 변수는 연산하기 전에 반드시 초기화해야 합니다.

단항 증가 연산이 문법적으로 조금 어려운 부분은 전위식 표기(`++x`)일 경우엔 연산자 우선순위가 높지만 후위식 표기(`x++`)이면 우선순위가 사실상 최하위가 되기 때문입니다. 그러므로 단항 증감 연산을 후위식으로 표기했다면 해당 구문에서 마치 그 단항 연산이 없는 것처럼 생각하는 것이 맞습니다.

```c
#include <stdio.h>

int main(void)
{
    int x = 0, nResult = 0;

    // x의 값을 1 증가시킨 후 출력
    ++x;
    printf("%d\n", x);

    // x의 값을 1 증가시킨 후 출력
    x++;
    printf("%d\n", x);

    // x의 값을 1 증가시킨 후 단순 대입(전위식 표기)
    nResult = ++x;
    printf("%d, %d\n", nResult, x);

    // x의 값을 nResult에 대입 후 x를 1 감소(후위식 표기)
    nResult = x--;
    printf("%d, %d\n", nResult, x);
    return 0;
}
```

## 비트 연산자

C 언어가 제공하는 비트 연산자는 `AND(&)`, `OR(|)`, `XOR(^)`, `NOT(~)`, `Shift left(<<)`, `Shift right(>>)`가 있습니다. 이 중 `NOT(~)`은 단항 연산자이고 나머지는 모두 2항 연산자입니다. 그리고 비트 단위 상수를 기술할 때는 보통 **16진수**를 사용합니다.

### 1. 비트 연산자의 사용

```c
#include <stdio.h>

int main(void)
{
    int nData = 0x11223344;

    // 2진수로 변환하여 각 비트 단위 데이터를 비교해볼 것
    printf("%08x\n", nData & 0x00FFFF00);
    printf("%08x\n", nData | 0x2211FFFF);
    printf("%08x\n", nData ^ 0x2211FFFF);
    printf("%08x\n", ~nData);
    printf("%08x\n", nData >> 8);
    printf("%08x\n", nData << 16);
    return 0;
}
```
임의의 정보 `X`와 `1`을 비트 `AND` 연산하면 결과는 무조건 `X`입니다. `AND` 연산은 두 수 모두 `1(참)`이어야 결과가 `1`이기 때문입니다. `OR`의 경우에는 `AND`와 반대로 한쪽이 `1`이면 결과는 `1`입니다. 그리고 `XOR` 연산은 두 값이 서로 같을 경우에 `0`입니다. `NOT` 연산은 `0`과 `1`을 뒤집는 연산입니다. 값이 모두 정반대로 변경한다는 의미로 **인버터(inverter)**라고 부르기도 합니다. 비트 시프트 연산은 늘 '잘림'과 '채움'이 동시에 발생합니다. 정보가 밀리는 과정에서 자료형의 범위를 넘어가는 것은 모두 잘리고, 반대쪽으로는 잘려나간 만큼 새로 채워지는데 이 '채움'을 **패딩(padding)**이라고 합니다. 패딩하는 값은 기본적으로 `0`입니다. 그러나 오른쪽으로 시프트 할 경우엔 왼쪽 부호비트에 따라 `0`이 아닌 `1`로 패딩하기도 하는데, 이유는 부호를 유지하기 위함입니다.

### 2. 마스크 연산

상수 `0`과 변수의 특정 비트열에 대해 비트 `AND` 연산함으로써 일정 구간이 모두 `0`이 되도록 의도한 연산을 **마스크(mask)** 연산이라고 합니다. 여기서 마스크라는 것의 의미는 불필요한 정보를 가려서 필요한 정보만 골라 냄을 의미합니다.

```c
#include <stdio.h>

int main(void)
{
    int nData = 0x11223344;

    printf("%08x\n", nData & 0xFFFF0000);  // 하위 16비트만 모두 0으로 초기화
    printf("%08x\n", nData & 0x00FFFF00);  // 상위 8비트와 하위 8비트만 0으로 초기화
    printf("%08x\n", nData & 0x0000FFFF);  // 상위 16비트만 모두 0으로 초기화
    printf("%08x\n", nData & 0xFF0000FF);
    return 0;
}
```
