# 함수에 대한 기본

각종 연산식이 모여 한 **구문**을 이루고, 다시 여러 구문이 의미 있는 **절차상의 흐름**을 만들고, 그 절차상의 흐름이 하나로 뭉쳐 **함수**를 이루고, 다시 함수가 함수를 호출하여 연계하고 그렇게 또 다른 흐름을 만듦으로써 C 언어 기반의 **프로그램**이 완성됩니다.

그리고 함수와 반복문은 반복되는 코드들을 처리하는 것과 관련된 문법입니다. 그러나 반복문은 연속적인 반복을 의미하고 함수는 **불연속적인 반복을 통한 코드의 재사용**을 의미합니다.

## 사용자 정의 함수의 선언 및 정의

사용자 정의 함수(user-defined function)는 필요에 의해 개발자 본인 스스로 만들어낸 함수를 의미합니다. `main()` 함수도 사용자 정의 함수입니다. 그러므로 지금까지 작성한 모든 예제는 사실, 특정 사용자 정의 함수의 내부 절차적 흐름을 정의한 것이었습니다. 그리고 우리는 그것을 '프로그램'이라고 불렀습니다.

```c
#include <stdio.h>

int Add(int a, int b)
{
    // Add() 함수의 지역변수 선언 및 정의
    int nData = 0;
    nData = a + b;

    // 호출자 함수에 반환
    return nData;
}

int main(void)
{
    int nResult = 0;
    nResult = Add(3, 4);
    printf("Result: %d\n", nResult);
    return 0;
}
```
어떤 함수를 호출하는 함수를 '호출자(caller)'라고 부르고 반대로 호출되는 함수를 '피호출자(callee)'라고 부릅니다.

'함수 정의'라는 것은 함수의 내부를 이루는 구문들을 실제로 기술하는 것을 의미합니다. 그리고 '함수 선언'은 **반환 자료형, 함수이름, 매개변수** 등을 기술하여 함수의 외형적 특성을 기술한 문법입니다.

함수의 매개변수와 반환 자료형은 함수의 사용방법을 결정합니다. 매개변수의 개수가 많아지면 호출자는 명시해야 할 인수가 그만큼 늘어나고 함수 호출(혹은 사용) 방법이 복잡할 수 있습니다. 따라서 불필요하게 매개변수를 늘리는 행위는 바람직하지 않습니다.

그리고 프로그램의 시작은 언제나 `main()` 함수입니다. C 언어로 작성된 콘솔 기반 응용 프로그램은 무조건 `main()` 함수에서 시작합니다.

### 1. 매개변수

함수의 **매개변수(parameter)**는 호출자와 피호출자를 연결해주는 매개체입니다. 그런데 이 매개변수라는 것이 말 그대로 '변수'입니다. 좀 더 정확히는 피호출자 함수 내부에 선언된 지역변수입니다. 그리고 매개변수가 사용하는 메모리 영역은 그동안 배운 변수들과 같은 영역을 사용합니다. **스택 영역**을 사용하는 **자동변수**입니다.

### 2. 반환 자료형

함수의 반환 자료형은 호출자 함수가 피호출자 함수를 호출해서 얻을 수 있는 **정보의 형식**입니다. 그리고 함수가 반환한 자료는 연산의 '임시 결과'처럼 즉시 활용하거나 저장하지 않으면 유실됩니다.

`return` 제어문은 호출자 함수에 정보를 반환합니다. 만일 함수의 자료형이 `void`라면 `return`문의 오른쪽에는 아무것도 기술하지 않습니다. 그리고 반환자료가 반드시 변수나 상수일 필요는 없습니다. 경우에 따라 연산식(`return a + b;`)이 될 수도 있고 다른 함수(`return TestFunc();`)가 될 수도 있습니다.

## 두 가지 함수 설계 원칙

함수들은 호출/피호출자 관계로 묶어(binding) 코드를 확장합니다. C 언어 프로그래머가 해야할 고민은 **무엇을(어떤 기능을 수행하는) 함수로 만들어야 하는가**입니다.

- 사용자 인터페이스(겉으로 드러나는 외형)와 내부기능은 반드시 분리할 것
- 하나의 단위기능(예: 평균 계산, 최대값 찾기, 정렬)으로 규정할 수 있는 대상은 함수로 만들 것

### 1. UI와 기능의 분리

다음 예제는 계승을 계산하는 함수를 구현한 것입니다. 기능적으로나 문법적으로 전혀 문제가 없지만, 계승을 계산하는 함수 내부에서 문자열로 에러 메시지를 출력하는 것은 바람직하지 않습니다.
```c
#include <stdio.h>

int GetFactorial(int nParam)
{
    int nResult = 1, i = 0;
    if (nParam < 1 || nParam > 10)
    {
        puts("ERROR: 1~10사이의 정수를 입력하세요.");
        return 0;
    }

    for (i = 1; i <= nParam; ++i)
        nResult *= i;
    return nResult;
}

int main(void)
{
    printf("MAX: %d\n", GetFactorial(1));
    printf("MAX: %d\n", GetFactorial(5));
    printf("MAX: %d\n", GetFactorial(11));
    printf("MAX: %d\n", GetFactorial(10));
    return 0;
}
```
`GetFactorial()` 함수가 반환한 값이 0인지 비교함으로써 오류를 판단할 수 있습니다. 그런 방법이 있음에도 불구하고 기능 함수 내부에서 사용자 인터페이스의 영역에서 해야 할일을 처리하는 것은 생각해볼 문제입니다. 예제에서 사용자 인터페이스를 담당하는 것은 호출자 함수인 `main()` 함수입니다.

```c
#include <stdio.h>

int GetFactorial(int nParam)
{
    int nResult = 1, i = 0;
    // 매개변수 값이 유효하지 않다면 0을 반환함으로써 호출자 함수에 오류를 전달
    if (nParam < 1 || nParam > 10)  return 0;

    for (i = 1; i <= nParam; ++i)
        nResult *= i;
    return nResult;
}

// 화면 출력과 관련한 코드는 모두 main() 함수가 담당
int main(void)
{
    int nResult = 0, nInput = 0;

    printf("계승을 구할 정수(1~10)를 입력하세요. : ");
    scanf("%d", &nInput);

    nResult = GetFactorial(nInput);
    if (nResult == 0)
    {
        puts("ERROR: 1~10사이의 정수를 입력하세요.");
        return 0;
    }

    printf("Result: %d\n", nResult);
    return 0;
}
```
위의 예제는 기능과 UI의 분리가 명확합니다.

이어서 살펴볼 예제는 실제로 작동하는 기능은 전혀 없고 단지 UI만 존재하는 '관리 프로그램'입니다.
```c
#include <stdio.h>
#include <stdlib.h>

// 화면에 메뉴를 출력하는 함수의 선언 및 정의
int PrintMenu(void)
{
    int nInput = 0;

    // 메뉴를 출력하기 전에 화면을 지운다. (Clear screen)
    system("cls");
    // 메뉴를 출력하고 사용자 입력을 받는다.
    printf("[1]New\t[2]Search\t[3]Print\t[4]Remove\t[0]Exit\n");
    scanf("%d", &nInput);

    // 사용자가 선택한 메뉴 값을 반환
    return nInput;
}

int main(void)
{
    int nMenu = 0;

    // 메뉴 이벤트 루프
    // 사용자가 입력한 값에 따라 정해진 기능을 반복해 수행한다.
    while ((nMenu = PrintMenu()) != 0)
    {
        switch(nMenu)
        {
            case 1:     // New
                puts("새 항목을 추가합니다.");
                break;
            case 2:     // Search
                puts("기존 항목에서 검색합니다.");
                break;
            case 3:     // Print
                puts("전체 내용을 출력합니다.");
                break;
            case 4:     // Remove
                puts("기존 항목을 삭제합니다.");
                break;
            default:
                puts("알 수 없는 명령어입니다.");

        }
        getchar();
    }
    puts("Bye~~!");
    return 0;
}
```
`main()` 함수에서 `PrintMenu()` 함수를 반복해서 호출하고 있습니다. 이러한 반복 구조를 **이벤트 루프(event loop)**라고 부릅니다.

### 2. 재사용 가능한 단위 기능의 구현

불연속적으로 반복되거나 앞으로 다시 사용될 가능성이 높은 코드는 함수로 만드는 것이 좋습니다. 그러나 반복이나 재사용 같은 이유가 아니라도 함수로 만드는 것이 좋을 때가 있습니다.

설계 원칙으로 DRY(Don't repeat yourself) 원칙이 있습니다. DRY 원칙의 핵심은 "같은 일을 수행하는 코드가 중복되지 않도록 하라"입니다. 이유는 논리적 오류방지와 유지보수 때문입니다. 본래 소프트웨어라는 것은 하드웨어와 달리 수시로 변합니다. 결함 때문일 수도 있지만, 변화한 환경에 능동적으로 대응하기 위한 이유가 더 큽니다.

## 코드 분할

어떤 코드를 함수로 만들어야 할 이유중 코드 분할이라는 이유도 있습니다. 덩치가 너무 큰 코드는 변화에 대응하기가 어렵습니다. 즉, 유지보수 하기가 어렵다는 뜻입니다. 따라서 자신 스스로 너무 큰 코드라고 판단되면 일정 수준으로 크기를 줄여 여러 함수로 코드를 나누는 것이 좋습니다. 코드를 분할 할 때 넘겨줄 정보와 받아낼 정보가 무엇인지 형식수준에서 구체화해야 합니다.

[실습문제](../code/10/01.c)

### 1. 함수의 원형 선언

변수와 함수는 문법적으로 **선언(declaration)과 정의(definition)가 분리**될 수 있습니다. 그리고 경우에 따라서 함수의 선언이 반드시 별도로 존재해야 할 수도 있습니다. 이럴 때는 **함수의 원형(prototype) 선언**을 소스코드 상단에 기술함으로써 컴파일러에 함수의 존재를 알려야 합니다.

```c
#include <stdio.h>

// 선언
int Add(int, int);

int main(void)
{
    printf("%d\n", Add(3, 4));
    return 0;
}

// 정의
int Add(int x, int y)
{
    return x + y;
}
```

### 2. 전역변수

전역변수는 소스 파일 전체에서 접근(파일 스코프)할 수 있는 형태로 선언 및 정의 된 변수입니다. 전역변수는 프로그램이 최초 실행될 때(`main()` 함수가 실행되기도 전)부터 이미 존재하는 것이며 프로그램이 끝날 때까지 사라지지 않고 유지됩니다.

```c
#include <stdio.h>

// 전역변수 선언 및 정의
int g_nCounter = 0;

void InitCounter(int nData)
{
    g_nCounter = nData;
}

void IncreaseCounter()
{
    g_nCounter++;
}

int main(void)
{
    InitCounter(10);
    printf("%d\n", g_nCounter);
    IncreaseCounter();
    printf("%d\n", g_nCounter);
    IncreaseCounter();
    printf("%d\n", g_nCounter);

    return 0;
}
```
전역변수는 매우 편리한 것이 맞습니다. 하지만 서로 떨어져 독립적이어야 할 두 코드를 하나로 묶어주는 역할을 수행하기 때문에 불필요한 의존관계가 형성됩니다. 이는 설계적으로 매우 부적절합니다.

좋은 설계라는 것은 프로그램을 적절한 단위요소로 나누고 각 요소가 다른 요소의 변화에 영향을 받지 않도록 **의존성을 최대한 낮추는 것**입니다.

### 3. 전역변수와 식별자 검색 순서

변수의 이름은 식별자로 사용됩니다. 통용범위가 다르면 이름은 중복될 수 있습니다.

```c
# include <stdio.h>

int nInput = 100;

void TestFunc(void)
{
    printf("TestFunc() : %d\n", nInput);
}

int main(void)
{
    int nInput = 0;
    printf("%d\n", nInput);
    {
        int nInput = 20;
        printf("%d\n", nInput);
    }
    TestFunc();
    return 0;
}
/* 출력:
0
20
TestFunc() : 100
*/
```
전역변수의 이름 앞에는 `g_`처럼 전치사를 붙이는 것이 좋습니다. 변수의 이름만 봐도 전역변수라고 짐작할 수 있기 때문입니다.

전역변수와 지역변수가 이름이 중복될 경우엔 지역변수가 우선합니다. C언어가 변수에 대한 식별자를 검색하는 순서를 정리하면 다음과 같습니다.

1. 가장 최근에 형성된 블록 스코프에 속한 지역변수
2. 현재 블록 스코프의 외부를 감싸고 있는 상위 스코프(최대 함수 몸체까지 검색)
3. 파일 스코프(전역변수)


## 연습문제

[문제 01](../code/10/02.c)

[문제 02](../code/10/03.c)
