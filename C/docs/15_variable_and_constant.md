# 변수와 상수 고급 이론

**변수의 본질은 메모리**이고, 상수의 본질은 메모리에 저장되는 정보 그 자체를 의미합니다. 이 장에서는 **최적화(optimization)**와 관련된 이론을 다룹니다.

## 형한정어

형한정어(type qualifier)는 변수에 적용되는 문법으로서 컴파일러의 최적화와 매우 밀접하게 관련되어 있습니다.

### 1. `const`

형한정어 `const`는 변수를 **상수화**하는 역할을 합니다. 변수의 본질이 메모리임을 생각할 때 쉽게 생각하면 **어떤 메모리를 '읽기 전용' 메모리로 만들어 주는 기능**을 제공하는 것으로 이해할 수 있습니다.

변수가 선언 및 정의될 때부터 상수화를 해야 하는 이유는 무엇일까요. **유지보수를 쉽게 하기 위함**이비다. 그리고 컴파일러의 입장에서는 줄어든 변수의 수만큼 번역도 유리하며 **성능향상**을 꾀하기도 쉬워집니다.

다음 예제는 사용자로부터 점수를 입력받아 70점 이상이면 '합격', 그렇지 않으면 '불합격'이라고 출력하는 간단한 프로그램입니다. 이 예제에서 **나중에 변경될 가능성이 높은 처리 조건이 무엇인지 고민**해봅니다.

```c
#include <stdio.h>

int main(void)
{
    int nInput = 0;
    printf("점수를 입력하세요.: ");
    scanf("%d", &nInput);
    
    if (nInput >= 70)   printf("합격입니다.\n");
    else                printf("불합격입니다.\n");
    return 0;
}
```
이 예제가 기술적으로나 문법적으로 잘못된 것은 없습니다. 그러나 '유지보수' 측면에서 문제가 있습니다. 만일 합격 기준점수가 75점 이상으로 정책이 변경되었다고 가정해봅시다. 70이라는 합격조건을 **리터럴 상수로 기술한 것이 잠재적인 문제**라고 할 수 있습니다.

```c
#include <stdio.h>

int main(void)
{
    // 상수화된 변수 선언 및 정의
    // 문법적으로 nCUTOFF의 값은 변경할 수 없다!
    const int nCUTOFF = 70;
    int nInput = 0;
    printf("점수를 입력하세요.: ");
    scanf("%d", &nInput);
    
    if (nInput >= nCUTOFF)   
        printf("합격입니다.\n");
    else                    
        printf("불합격입니다.\n");
    return 0;
}
```
경험이 많은 개발자는 "IT 기술로서의 프로그래밍 요소"와 "정책 혹은 기획에 의한 사용자 요구"를 구별하여 프로그램을 개발할 수 있는 능력이 있습니다. 이 중 후자는 변경될 가능성이 높습니다. 어떨 때는 수시로 달라지기도 합니다. 정책이나 기획이라는 것은 늘 변화에 예민합니다.

기술은 '공부'라는 자신만의 노력으로 얻을 수 있습니다. 그러나 **사용자 요구 분석 능력은 '현실경험'에 의해서 완성**됩니다.

이 예제처럼 **상수형 변수를 사용해서 합격점수를 표기하면, 유지보수성이 대단히 좋아집니다.** 일일이 찾아서 수정할 필요가 없는 데다 결정적으로 어느 것도 빼먹고 놓칠 가능성이 없습니다.

프로그래머는 75라는 숫자로 정책적인 요소를 기술하기보다는 '커트라인'같은 표현으로 프로그램을 완성하려는 노력이 필요합니다. 이처럼 특정 숫자와 변수의 이름을 조합하여 좀 더 의미가 명확해 보이는 상수를 표현할 수 있는데, 이를 **심볼릭 상수(symbolic constant)**라고 합니다.

### 2. 상수형 포인터

C 언어는 여전히 고급어 중 최고의 성능을 자랑합니다. 그도 그럴 것이 "이 언어가 진짜 고급언어가 맞기는 한 것인가"라는 의문이 들 정도로 많은 하드웨어 지식을 요구하기 때문입니다. 그런데 C 언어로 장치를 제어할 목적이 아니라면 C 언어는 오히려 비효율적인 개발방법이 될 수도 있는 세상이 되어 버렸습니다. 그리고 그 원인을 제공하는 것 중 하나는 바로 '포인터'입니다.

이 때문에 다른 고급 언어들은 이 포인터를 아예 지원하지 않거나 안전한 사용형식으로만 사용할 수 있도록 제한하는 제3의 문법을 지원하고 이름도 다른 것으로 바꿉니다. 대표적으로 C++의 '참조자(reference type)'가 그러합니다.

문제는 포인터를 너무 남발할 경우 **C 언어를 기계어로 번역할 때 효율적인 기계어 코드가 될 수 있도록 번역하기가 어렵습니다.** 또한 프로그램의 동시성(병렬처리나 멀티스레딩)을 심각하게 떨어 뜨리기도 합니다. 이런 골치 아픈 문제를 **포인터를 상수화함으로써 컴파일러를 도와줄 수는 있습니다.**

```c
#include <stdio.h>

int main(void)
{
    char szBuffer[32] = {"I am a boy."};
    // 가리키는 대상을 상수화한 포인터 변수 선언 및 정의
    const char *pszBuffer = szBuffer;

    // 문자 배열의 내용은 변경 가능
    szBuffer[0] = 'i';

    // 포인터가 가리키는 대상을 간접지정할 수는 있지만 l-value로 사용 불가능
    *pszBuffer = 'i';
    return 0;
}
```
```shell
error: read-only variable is not assignable
```

`const`가 수식하는 대상은 `pszBuffer`라는 포인터 자체가 아니라 **포인터가 가리키는 대상**입니다. 만일 상수화된 포인터가 아니라 일반 포인터라면 그 대상 메모리에 쓰기를 수행(l-value로 활용)해도 문법적으로 아무 문제가 없습니다. 그러나 상수형 포인터는 이를 허용하지 않습니다. 위의 예제가 오류인 이유도 **상수화된 대상에 쓰기를 시도**했기 때문입니다.

물론 `szBuffer` 배열 전체가 읽기 전용 메모리로 둔갑한 것이 아닙니다. 다만 이 배열에 이를 수 있는 또 다른 방법인 `pszBuffer` 포인터에 대해서 읽기는 허용하지만 쓰기를 허용하지 않을 뿐입니다.

코드가 두 개의 함수로 분할된 상황에서 피호출자 함수가 주소를 매개변수로 받는 **Call by reference 형식인 경우, 피호출자 함수의 연산으로 인해 호출자의 메모리가 변경될 가능성이 없도록 문법적으로 강제화**하는 노력이 필요할 수 있습니다.

```c
#include <stdio.h>

// 매개변수가 상수형 포인터이다.
// 따라서 함수에서 포인터가 가리키는 대상 메모리에 쓰기를 시도할 수 없다.
void PrintString(const char *pszParam)
{
    puts(pszParam);
}

int main(void)
{
    char szBuffer[32] = {"I am a boy."};

    // PrintString() 함수를 호출하더라도 szBuffer가 변경될 가능성은 없다.
    PrintString(szBuffer);
    PrintString("You are a girl");
    return 0;
}
```
함수 내부에서 대상 메모리에 쓰기를 시도할 일이 없다는 것이 확실하다면 매개변수를 상수형 포인터로 선언하는 것이 중요합니다.

```c
#include <stdio.h>

int main(void)
{
    int nData = 10;

    // 포인터가 가리키는 대상을 상수화
    const int *pnData = &nData;
    // 포인터 변수 자체를 상수화
    int* const pnNewData = &nData;

    // 아래 두 구문 모두 에러
    *pnData = 20;
    pnNewData = NULL;
    return 0;
}
```

`const int *pnData = &nData;` 코드는 **포인터 변수가 '가리키는 대상'이 상수화**됩니다. `int* const pnNewData = &nData;` 코드는 **'포인터 변수 그 자체'를 상수화**합니다. 즉, 포인터가 가리키는 메모리는 수정할 수 있으나 포인터가 변해서 다른 대상을 가리킬 수는 없는 상태가 됩니다.

만일 `const int* const pnNewData = &nData;`라고 수정하면, 포인터가 가리키는 대상도 그리고 그 자신도 모두 상수화됩니다. 따라서 간접지정한 대상을 변경할 수도 없고 포인터가 다른 대상을 가리키도록 변경할 수도 없습니다.


### 3. 심볼릭 상수를 만드는 또 다른 방법

심볼릭 상수를 만드는 방법으로 형한정어 `const`를 사용하는 방법 외에 한 가지 방법이 더 있습니다. 그것은 바로 `#define` 전처리기를 이용하여 상수를 정의하는 방법입니다.

```c
#include <stdio.h>

// 전처리기로 심볼릭 상수를 정의
#define CUTOFF 70

int main(void)
{
    int nInput = 0;
    printf("점수를 입력하세요. : ");
    scanf("%d", &nInput);

    if (nInput >= CUTOFF)   printf("합격입니다.\n");
    else                    printf("불합격입니다.\n");
    return 0;
}
```

`CUTOFF`라는 이름은 **컴파일을 진행하기에 앞서 모두 70으로 변경**됩니다. 쉽게 생각해서 컴파일러가 '찾기 바꾸기'를 수행한 후에 번역을 시작한다고 볼 수 있습니다. 심볼릭 상수를 정의할 때 형한정어 `const`를 이용하든 '전처리기'를 이용하든 외형상 크게 달라질 것은 없습니다. 그러나 '전처리기'를 이용한 심볼릭 상수는 상수화된 변수와 달리 **문법적으로 완전히 상수**입니다.

### 4. `volatile`

형한정어 `volatile`을 적용해 변수를 선언하면 **변수와 관련된 모든 연산에 대해 컴파일러가 '최적화' 규칙을 적용하지 않습니다.** 설령 그것이 컴파일러가 판단하기에 전혀 불필요한 연산이라고 해도 말이죠. 그런 의미에서 **컴파일러의 최적화의 도움을 주는 `const`**와는 정반대의 역할을 수행한는 것으로 볼 수 있습니다. 그리고 여기서 '최적화'를 하지 않는 수준이 CPU 기계 수준까지 적용됩니다.

비효율적임을 알고 있으나 꼭 해야 하는 연산이 있을 수 있습니다. 그런데 그런 속사정을 컴파일러가 알아 줄 리가 없습니다. 전현 불필한 요소라고 판단해 아예 번역하지 않는다면 소스코드의 의미가 그대로 기계어로 번역되지 못할 수 있습니다. 이런 경우는 주로 임베디드 프로그래밍 환경입니다.

최적화는 가끔 두려움의 대상이 될 때가 있습니다. 많은 C/C++ 개발자들이 자신의 PC에서 개발할 때는 아무 문제가 없다가, 프로그램을 완성하여 고객에게 전달하라겨 할 때 문제가 나는 현상을 경험합니다. 디버그 모드로 빌드하면 전혀 문제가 없던 프로그램이 릴리즈 모드로 빌드하는 순간 상상하지도 못한 버그들이 발견되거나 기술적으로 설명할 수 없는 결과가 야기되는 일은 종종 벌어집니다. 항상 그런 것은 아니지만 상당수 원인이 바로 이 '최적화' 때문입니다.

```c
#include <stdio.h>

int main(void)
{
    volatile int nData = 10;
    int i = 0;

    // 비효율적이나 꼭 해야 하는 연산
    for(i = 0; i < 100; ++i)
        nData = 10;

    printf("%d\n", nData);
    return 0;
}
```

## `extern` 외부변수 선언

외부 변수 선언과 관련된 예제는 한 프로젝트에 최소한 두개 이상의 소스코드 파일이 존재합니다.

```c
// VariableExtern01.c file

#include <stdio.h>

// (다른 외부 파일에 정의된)함수의 원형 선언
void InitCounter(int nData);
void IncreaseCounter();

// (다른 외부 파일에 정의된)전역변수 선언(정의가 아님!)
extern int g_nCounter;

void main(void)
{
    InitCounter(10);
    printf("%d\n", g_nCounter);
    IncreaseCounter();
    printf("%d\n", g_nCounter);
}
```

빌드하고 다음과 같은 오류 메시지를 확인합니다.

```shell
Undefined symbols for architecture x86_64:
  "_IncreaseCounter", referenced from:
      _main in temp-07cd31.o
  "_InitCounter", referenced from:
      _main in temp-07cd31.o
  "_g_nCounter", referenced from:
      _main in temp-07cd31.o
```

프로젝트에 새로운 소스코드를 추가하고 다음과 같이 코드를 작성합니다. 

```c
// Test.c file

#include <stdio.h>

int g_nCounter = 0;

void InitCounter(int nData)
{
    g_nCounter = nData;
}

void IncreaseCounter()
{
    g_nCounter++;
}
```

빌드하고 실행해서 결과를 확인합니다. (`gcc VariableExtern01.c Test.c -o testname`)

`Test.c` 파일에는 `main()` 함수가 없습니다. 한 프로젝트 내부에 여러 파일이 존재할 때는 **오로지 한 파일에만 `main()` 함수가 존재**해야 합니다. 그리고 외부변수 선언은 일반 변수 선언과 같은 형식으로 기술하지만, 자료형 앞에 `extern` 예약어를 붙이면 됩니다. 그러나 **절대로 초기값을 명시하면 안 됩니다.**

obj 파일이 만들어지는 컴파일 과정에서는 선언만 있어도 아무 문제가 없다는 것입니다. 다른 obj 파일에 정의가 존재한다고 가정하고 넘어가기 때문입니다. 그러나 링크 타임에는 이 둘을 하나로 합치는데 이 과정에서 원형 선언이나 외부변수로 선언된 것들의 실체가 어느 obj 파일에 존재하는지 검색하여 짝을 맞춥니다.

결국 **외부변수라는 말의 의미는 변수의 정의가 현재 파일이 아니라 다른 파일(외부파일)에 존재한다는 의미**입니다. 따라서 일단 컴파일은 넘기고 링크 과정에서 다른 외부 obj 파일에서 실체를 찾습니다. 그러나 만일 여기서 정의를 찾지 못하면 링크 오류가 발생합니다.

## 형 재선언

형 재선언은 `typedef` 예약어를 이용해 **새로운 자료형을 선언하는 문법**입니다. 그리고 `typedef` 예약어로 선언된 새 자료형을 **사용자 정의 형식**이라고 합니다.

다음 예제는 `unsinged int`형을 `UINT`로 재정의하고 사용한 예를 보인 것입니다.

```c
#include <stdio.h>

typedef unsigned int UINT;

int main(void)
{
    UINT uData = 10;
    printf("%u\n", uData);
    return 0;
}
```

`typedef` 대신 `#define` 전처리기를 이용해서 같은 효과를 얻을 수 있습니다. 그러나 형 재선언은 정말로 새로운 자료형이 하나 생겨나는 것이고, 전처리기를 이용하면 단지 번역에 앞서 치환될 정보가 하나 추가된 것에 불과합니다.

형 재선언을 남발할 경우, **자칫하면 분석하기 너무나 힘든 코드**가 되어 버릴 수도 있습니다.

## 열거형 상수

열거형 상수는 `#define` 전처리기처럼 심볼릭 상수를 정의하는 것과 같습니다. 차이가 있다면, 하나가 아니라 **여러 개의 심볼릭 상수를 한꺼번에 정의**하고 구조체처럼 새로운 **사용자 정의 자료형**으로 활용하는 것도 가능하다는 점입니다.

```c
enum 형식명 {값이름[= 정수], 값이름[= 정수], ...};
```

```c
#include <stdio.h>

// 열거형 상수 ACTION 선언 및 정의
// MOVE는 0(int), JUMP는 1, ATTACK은 2
enum ACTION {MOVE, JUMP, ATTACK};

// 형 재선언을 포함하는 열거형 상수 선언 및 정의
// RED 100, GREEN 101, BLUE 102
typedef enum COLOR {RED = 100, GREEN, BLUE} COLOR;

int main(void)
{
    enum ACTION act = MOVE;
    COLOR color = GREEN;

    // 열거형 상수는 int형식 상수
    printf("ACTION: %d, COLOR: %d\n", act, color);
    return 0;
}
```
사실 열거형 상수는 내부적으로 `int`형 자료에 지나지 않습니다. 그러나 거기에 이름을 부여함으로써 의미를 명확히 할 수 있습니다.

열거형 상수를 잘 활용하기 바랍니다. 불필요한 자료형이 생성되어 문제가 된다고 볼 수 있을지도 모르겠습니다. 실제로 잘못하면 그렇게 될 수도 있습니다. 그러나 잘만 사용하면 별도의 주석문이 없어도 누구나 이해하기 쉬운 코드를 작성할 수 있습니다. 그러면 유지보수 하기도 편해집니다. 읽기 좋은 코드를 만들기 위한 노력은 매우 중요합니다.
