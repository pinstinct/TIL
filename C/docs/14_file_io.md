# 파일 입출력

파일(file)은 보조기억장치에 저장되어 관리되는 정보의 단위입니다. 변수나 동적 할당한 메모리가 주기억장치를 사용하기 위한 요소라면 파일은 보조기억장치를 사용하기 위한 요소이며, **파일 시스템(file system)**이라고 부르는 별도의 관리 체계가 존재합니다.

보조기억장치는 주기억장치와 달리 용량문제에 매우 둔감합니다. 주기억장치나 보조기억장치나 같은 메모리지만 사용하는 방법이 그 속성만큼이나 서로 다릅니다.

## 파일 시스템 기본 이론

파일 시스템은 **파일 단위로 정보를 생성, 삭제, 저장, 검색할 수 있도록 정보를 구성하는 방법**을 말합니다. 이 정보에는 파일의 이름이나 위치 등에 대한 정보도 포함됩니다. 파일의 위치를 말할 때, **경로(path)**라는 말을 사용합니다.

### 1. 텍스트 파일과 바이너리 파일

파일은 크게 **텍스트 파일**과 **바이너리(binary) 파일**로 나눌 수 있습니다. 텍스트 파일은 파일에 저장된 정보가 모두 **ASCII 코드나 문자열로 해석할 수 있는 정보**들로만 구성된 파일을 말합니다. 텍스트 파일의 가장 중요한 특징 중 하나는 -1이라는 정수값을 '파일의 끝(EOF, End Of File)'으로 인식한다는 점입니다.

그리고 **텍스트 파일을 제외한 모든 파일들을 바이너리 파일**이라고 합니다.

### 2. `fopen()`, `flocse()` 함수

`fopen()` 함수는 특정 경로에 있는 파일을 열어서 접근할 수 있도록 `FILE` 구조체에 대한 주소를 반환하는 함수입니다. 사용이 끝나면 `fclose()` 함수로 닫아주어야 합니다.

```c
FILE *fopen(const char *filename, const char *mode);
```

- 인자
  - filename: 열고자 하는 대상 파일의 절대 경로 문자열
  - mode: 접근 모드를 명시한 문자열
- 반환값: `FILE` 구조체에 대한 주소 반환, 만일 에러가 발생하면 `NULL` 반환

```c
int fclose(FILE *stream);
```

- 인자: 닫을 파일에 대한 FILE 구조체의 주소
- 반환값: 함수가 성공하면 0을 반환하고 만일 에러가 발생하면 EOF 반환

```c
int _fcloseall(void);
```

- 인자: 없음
- 반환값: 닫은 파일의 개수
- 설명: 프로그램에서 열어둔 모든 파일을 닫는다.

```c
#include <stdio.h>

void main()
{
    // 파일 제어에 필요한 FILE 구조체에 대한 포인터 변수 선언 및 정의
    FILE *fp = NULL;
    // test.txt 파일을 쓰기 모드로 개방
    // 단, 같은 이름의 파일이 이미 존재하면 삭제하고 새 파일을 생성 (없다면 새로 생성)
    fp = fopen("Test.txt", "w");
    if (fp == NULL)
    {
        puts("ERROR: Failed to open file!");
        return;
    }

    // TODO: File I/O

    // 개방한 파일을 닫음
    fclose(fp);

}
```
위의 예제에서 생성할 파일의 이름만 명시하였는데 이는 상대 경로입니다. 따라서 `Test.txt`파일은 예제가 실행될 때 **현재 경로로 설정된 위치에 생성**됩니다.

#### 파일 접근 제어

만일 어떤 프로그램(혹은 시스템)이 이미 파일을 열어 두었다면, 접근이 제한될 수 있습니다. 이는 파일에 저장된 정보가 여러 프로그램에 의해 동시에 편집되어 엉키는 일이 발생하지 않도록 하기 위함입니다. 그러므로 파일을 다룰 때는 반드시 **접근 제어** 문제에 대해서 생각해야 하며, 다음 같은 사항들에 주의해야 합니다.

- 파일에 접근하려면 우선 파일을 개방해야 하며, 파일에 대한 입출력을 완료한 후에는 파일을 닫아야 한다.
- 파일을 개방할 때는 반드시 목적(입출력 혹은 수정)을 명시해야 한다.
- 파일이 이미 사용 중인 경우(파일이 개방된 상태), 접근이 제한될 수 있다. 그러나 경우에 따라 읽기는 허용될 수도 있다.
- 만일 파일의 속성이 '읽기 전용'이면 쓰기모드 개방이 제한된다.
- 경우에 따라(특히, 보안상 권한 문제 때문에) 읽기조차 제한될 수 있다.

```c
#include <stdio.h>

void main()
{
    FILE *fp = NULL;
    int nClosed = 0;
    fopen("Test1.txt", "w");
    fopen("Test2.txt", "w");
    fopen("Test3.txt", "w");

    // 지금까지 개방한 파일들을 '모두' 닫는다.
    nClosed = _fcloseall();
    printf("%d\n", nClosed);
}
```
파일이 개방된 상태에서 닫지 않고 프로그램이 종료되면, 특별한 일이 없는 한 운영체제 모든 파일을 닫아버립니다. 그러나 될 수 있으면 파일을 개방하고 닫는 일은 개발자 스스로 처리하는 것이 바람직합니다.

참고로 파일을 운영체제가 닫는 것과 관련해 '특별 한 일'이라는 것은 운영체제의 커널(kernel) 영역에서 특정 파일을 붙들고 놔주지 않는 경우입니다. 이런 경우는 보동 비동기 파일 입출력을 시도했을 때 발생합니다. 이에 대한 자세한 이론들은 시스템 프로그래밍을 배 울 때 알 수 있습니다.
