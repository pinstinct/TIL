# 함수 응용

## 매개변수 전달 방법

A 함수 내부에서 B 함수를 호출하는 코드가 있다면, A는 호출자이고 B는 피호출자입니다. 호출/피호출 관계로 묶이는 것이 **바인딩(binding)**입니다. 그리고 두 함수가 서로 연결되는 인터페이스는 바로 매개변수와 반환자료입니다. 그리고 함수호출 과정에서 매개변수로 전달되는 정보가 무엇이냐에 따라 **매개변수 전달방법**이 달라집니다. 값이냐 주소냐에 따라 **Call by value**와 **Call by reference**로 나뉩니다.

### 1. Call by value

다음은 전형적인 Call by value 예제입니다.
```c
#include <stdio.h>

int Add(int a, int b)
{
    return a + b;
}

int main(int argc, char* argv[])
{
    printf("%d\n", Add(3, 4));
    return 0;
}
```

### 2. Call by reference

Call by reference의 핵심은 매개변수가 **포인터**라는 점입니다. 따라서 호출자는 반드시 메모리의 **주소를 인수**로 넘겨야 합니다. 그리고 피호출자 함수는 이 매개변수를 간접지정함으로써 포인터가 가리키는 대상에 접근할 수 있습니다.

```c
#include <stdio.h>

int Add(int *a, int *b)
{
    return *a + *b;
}

int main(int argc, char* argv[])
{
    int x = 3, y = 4;
    printf("%d\n", Add(&x, &y));
    return 0;
}
```
Call by reference의 가장 큰 장점은 **배열처럼 덩치가 큰 메모리를 매개변수로 전달할 수 있다**는 점입니다.

```c
#include <stdio.h>

void GetName(char *pszName, int nSize)
{
    printf("이름을 입력하세요. : ");
    gets_s(pszName, nSize);
}

int main(int argc, char* argv[])
{
    char szName[32] = {0};
    GetName(szName, sizeof(szName));
    printf("당신의 이름은 %s입니다.\n", szName);
    return 0;
}
```
매개변수가 포인터일 때 포인터가 가리키는 대상 **메모리의 크기**를 인수로 받는 것은 보안적으로나 설계적으로 매우 중요합니다. 포인터의 가장 큰 문제는 가리키는 대상의 실제 크기를 포인터 자체만으로는 알 수가 없다는 점입니다.

매개변수 `char *pszName` 대신 `char pszName[]`라고 써도 의미가 같습니다. 문법적으로 둘 다 포인터입니다.

```c
#include <stdio.h>

// 매개변수로 주소를 받는다.
void Swap(int *pLeft, int *pRight)
{
    // 주소가 가리키는 대상의 메모리의 값을 교환
    int nTmp = *pLeft;
    *pLeft = *pRight;
    *pRight = nTmp;
}

int main(int argc, char* argv[])
{
    int x = 10, y = 20;
    Swap(&x, &y);
    printf("%d %d\n", x, y);
    return 0;
}
```
위의 예제는 Call by reference가 필요한 가장 대표적인 상황을 설명하는 예제입니다. 반드시 이해하고 넘어가야합니다.

```c
#include <stdio.h>

// 매개변수로 전달된 문자열의 길이를 반환하는 함수
int GetLength(const char *pszParam)
{
    int nLength = 0;
    while (pszParam[nLength] != '\0')
        nLength++;

    return nLength;
}

int main(int argc, char* argv[])
{
    char *pszData = "Hello";
    printf("%d\n", GetLength("Hi"));
    printf("%d\n", GetLength(pszData));
    return 0;
}
```
`const`는 **형한정어(type qualifier)**이며 `char*`인 매개변수 `pszParam`을 통해 간접지정한 대상을 상수화한다는 의미입니다. 즉, 간접지정한 대상에서 정보를 읽을 수는 있지만 쓸 수는 없다는 뜻입니다. `const` 형한정어를 잘 활용하면 피호출자 함수가 의도하지 않게 혹은 실수로 호출자가 전달한 주소의 메모리에 쓰기 연산하는 일을 방지할 수 있습니다.

[실습문제](../code/12/01.c)

#### 잘못된 주소 전달

운영체제에 반환했거나 곧 사라질 메모리에 대한 주소를 반환하는 일은 없어야 합니다. 예를 들어 함수 내부에 선언된 자동변수의 주소를 반환하는 것입니다.

동적 할당된 메모리나 정적변수는 함수의 호출이나 반환과 아무런 관련이 없습니다. 동적 할당된 메모리는 `free()` 함수로 해제하기 전까지 유효하며 정적변수들은 프로그램이 끝나는 순간까지 유효합니다.

그러나 자동변수는 스택 영역을 사용하며, 스택은 스코프가 닫히면 그 내부에서 선언된 것들이 사실상 사라진다고 봐야 합니다. "사라졌다"가 아니라 "사라진다고 봐야한다"는 이유는 스택 메모리가 정말로 사라지거나 해제되는 것이 아니라 가용범위가 줄어드는 것(지정해제)에 불과하기 때문입니다.

## 스택 프레임 그리는 방법

자동변수는 스택 영역 메모리를 사용합니다. 자동변수는 `auto`로 선언된 변수를 말하는데 별도로 명시하지 않는 모든 지역변수는 모두 자동변수입니다. 함수의 매개변수 역시 자동변수이고 함수의 지역변수입니다.

스택은 선형 자료구조의 일종으로 정보를 층층이 쌓아 올린 구조입니다. 그리고 이 스택 영역은 시스템이 관리합니다. 따라서 개발자가 스택 메모리의 지정(할당이 아님)과 해제에 관여할 필요도 없으며 그래서도 안됩니다. 그러나 스택이 어떤 형식으로 관리되는지 구체적으로 알아야 하는데, 그 관리 형식을 스택 프레임(stack frame)이라 합니다.

#### 스택과 메모리의 주소는 반대방향으로 그린다

스택 왼쪽에는 함수 이름과 스코프의 시작 지점을 표시하고 오른쪽에는 식별자 이름을 기술합니다. 그림에서 스택은 위로 증가합니다. 그러나 메모리의 주소는 아래로 증가합니다. 따라서 **메모리의 주소가 증가했다는 것은 스택이 줄어들었음을 의미**하고 주소값이 작아졌다는 것은 스택의 증가를 의마한다고 생각할 수 있습니다.

#### 지역 변수는 선언된 순서대로 그린다

선언된 순서대로 그렸다는 말을 정확하게 표현하자면 "먼저 스택에 Push 했다"라고 합니다. Push는 스택에 정보를 넣는 것이고 반대로 빼내는 것은 Pop이라고 합니다.

#### 포인터 변수는 별도로 표시한다

포인터 변수는 간접지정 대상이 어디인지 포인터가 가리키는 지점을 표시해야 합니다. 그러나 `NULL`로 초기화한 경우에는 그냥 `NULL`이라고 쓰고 선을 그어 표시하지 않습니다.

#### 배열의 인덱스는 아래로 증가하게 그린다.

배열의 인덱스는 주소가 증가하는 방향으로 표시해야 합니다. 따라서 0번 요소가 스택의 상단에 표시되도록 그립니다. 그리고 배열의 이름은 '주소상수'이므로 그 자체가 스택에 Push 되지 않는다는 사실에 주의합니다.

#### 동적 할당된 메모리는 따로 표시한다

만일 **메모리를 동적 할당하거나, 정적 영역을 사용하는 변수가 등장한다면 이는 스택 영역이 아니므로 별도로 그려서 표시**해야 합니다. 한 가지 주의해야 할 사항은 반드시 동적 할당된 **메모리의 크기**를 기술하고 동적 할당된 메모리의 기준주소를 포인터 변수가 가리키도록 선을 그어 표시해야 합니다.

## 재귀 호출

### 1. 재귀호츨을 이용한 문자열 출력

### 2. 재귀호출의 장/단점

## 문자/문자열 처리 함수

### 1. 문자 처리 함수

### 2. 문자열 처리 함수

### 3. 유니코드 문자열

## 유티리티 함수

### 1. `atoi()`, `atol()`, `atof()` 함수

### 2. `time()`, `localtime()`, `ctime()` 함수

### 3. `srand()`, `rand()` 함수

### 4. `system()`, `exit()` 함수