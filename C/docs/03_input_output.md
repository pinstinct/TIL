# 표준 입출력 도구

모든 HCI(Human Computer Interaction, 인간과 컴퓨터 간의 상호작용)는 입력(input)과 출력(output)에 기반합니다. 중요한 것은 "사용자가 의도한 입력 정보가 얼마나 정확하게 전달되는가"입니다.

## 문자 입출력

영문 한 글자를 입출력하는 데 사용하는 자료형은 `char`형입니다. 내부적으로 8비트 정수 형식입니다. 이 때문에 글자에 숫자를 더하거나 빼는 연산도 가능합니다.

### 1. `getchar()` / `putchar()` 함수

```c
int getchar(void);  // 문자 하나를 입력받기 위한 표준 입력 함수
```

- 인자 : 없음
- 반환값 : 입력 문자 하나, 자료형은 `int`형(`char`형 아님 주의, 둘은 크기의 차이만 있을 뿐 같은 정수형)

```c
int putchar(int c);
```

- 인자 : 출력할 문자 상수
- 반환값 : 출력 문자 하나, 자료형은 `int`형

```c
#include <stdio.h>

int main(void)
{
    char ch = 0;
    char ch = getchar();
    putchar(ch);

    // 0을 반환하고 main() 함수 반환 (프로그램 종료)
    return 0;
}
```

### 2. `_getch()` / `_getche()` 함수

`getchar()` 함수는 사용자가 입력한 문자가 어떤 것인지 그 정보 자체를 다루려는 목적이 강한 반면, `_getch()`, `_getche()` 함수는 단지 "아무 키나 눌려서 사용자 입력이 발생했음"을 감지하려는 목적이 더 강합니다. 글자를 입력하는 과정에서 `getchar()` 함수처럼 문자열을 입력하고 입력의 완료를 위해 Enter 키를 누를 필요가  없습니다. 한 글자라도 입력되면 `_getch()` 함수가 즉시 반환하기 때문입니다. `_getche()` 함수는 어떤 키가 눌렸는지 화면에 출력하고 함수가 반환한다는 점에서 차이가 있습니다.

## 문자열 입출력

문자열은 정확히 말해서 '문자의 배열'이라는 것입니다. 그러니까 'H', 'e', 'l', 'l', 'o', '\0'이라는 문자들이 한데 묶인 **집합체**라는 의미입니다. 중요한 사실은 문자를 다루는 것과 문자열을 다루는 것의 차이는 한 인스턴스(`char`)를 다루는 것과 여러 인스턴스(`char[n]`)를 묶어서 다루는 것의 차이라 할 수 있습니다.


배열의 이름은 주소입니다. 이 주소를 저장하기 위한 전용 변수가 바로 포인터(pointer)입니다.

### 1. `gets()` / `puts()` 함수

```c
char *gets(char *buffer);  // 표준입력장치(stdin)에서 문자열을 입력받는 함수
```

- 인자 : 입력받은 문자열을 저장할 메모리의 주소
- 반환값 : 인자로 전달받은 메모리 주소

```c
int puts(const char *string);  // 표준입력장치(stdin)에서 문자열을 출력하는 함수
```

- 인자 : 출력할 문자열이 저장된 메모리의 주소
- 반환값 : 음수가 아닌 값을 반환

`gets()` / `puts()` 함수는 각각 문자열을 입/출력 해주는 함수입니다. 매개변수는 포인터입니다.

```c
#include <stdio.h>

int main(void)
{
    // char 변수 32개가 한 덩어리로 묶인 배열 선언 및 정의
    char szName[32] = { 0 };

    // 사용자로부터 이름(문자열)을 입력받는다.
    printf("이름을 입력하세요: ");
    // 사용자가 입력한 문자들을 문자 배열에 모두 저장한다.
    gets(szName);

    // 배열에 저장된 이름을 화면에 출력한다.
    printf("당신의 이름은 ");
    puts(szName);
    puts("입니다.");
    return 0;
}
```

`puts()` 함수는 `printf()` 함수와 달리 자동으로 개행합니다.

### 2. `gets()` 함수와 보안 결함

```c
char *gets_s(char *buffer, size_t szieInCharacters);
```

- 인자
  - 입력받은 문자열을 저장할 메모리의 주소
  - 문자열이 저장될 메모리의 바이트 단위 크기
- 반환값 : 인자로 전달받은 메모리 주소

```
warning: this program uses gets(), which is unsafe.
```

`gets()` 함수를 사용하면, 보안 경고 메시지를 볼 수 있습니다. 보안적으로 안전하지 않다는 말은 보안 결함이 존재함을 의미합니다. 그 결함이라는 것은 "버퍼 오버플로우(overflow)에 의한 버퍼 오버런 공격(buffer overrun attack)에 대한 취약성"을 의미합니다.

```c
#include <stdio.h>

int main(void)
{
    char szName[32] = {0};

    printf("이름을 입력하세요: ");
    // Linux, Unix: fgets(szName, sizeof(szName), stdin)
    // Window: gets_s(szName, sizeof(szName));
    fgets(szName, sizeof(szName), stdin);

    printf("당신의 이름은 ");
    puts(szName);
    puts("입니다.");
    return 0;
}
```

## `printf()` 함수
형식 문자열에 맞춰 표준 출력 장치(stdout)에 문자열을 출력하는 함수입니다. 문자, 숫자(정수, 실수), 문자열 등의 정보를 하나로 조합하여 출력할 수 있는 강력한 기능을 제공합니다.
```c
int printf(const char *format [, argument]...);
```

- 인자
  - 형식 문자열이 저장된 메모리의 주소
  - 형식 문자열에 대응하는 가변인자들
- 반환값 : 출력할 문자열의 개수

`printf()` 함수를 제대로 사용하려면 우선 형식 문자열(format string)에 대해서 알아야 합니다. 형식 문자열은 문자열과 형식 문자, 그리고 이스케이프 시퀀스(escape sequence)로 구성됩니다. 그리고 함수를 호출하는 과정에서 구성된 최종 형식 문자열에 의해서 매개변수의 개수가 달라질 수 있는데, 이를 가변인자라고 합니다.

예를 들어 "XX는 YY를 잘한다."에서 'XX'와 'YY'가 형식 문자이며, 각각에 대응되는 '철수', '야구'가 가변인자입니다.

### 1. 형식 문자와 이스케이프 시퀀스

```c
int x = 10;
printf("x는 %d 입니다.\n", x);
```

"x는 %d 입니다.\n"라는 문자열이 형식 문자열이고, 그 안에 들어있는 %d는 형식 문자입니다. 가변인자로 기술된 변수 x에 담긴 정보를 10진수(%d) 형식으로 출력합니다.

형식문자 | 자료형 | 출력 형식
- | - | -
%c | int(char) | character. ASCII 문자로 출력
**%d** | int | Decimal. 부호가 있는 10진수로 출력
**%f** | double(float) | Float. 10진형 소수로 출력
**%s** | String | 인수가 가리키는 메모리의 내용을 **문자열(배열형태)**로 출력

특별한 의미를 지닌 문자(이스케이프 시퀀스)들이 있습니다. 이스케이프 시퀀스(escape sequence, 확장 비트열)는 출력장치(콘솔 화면이나 프린터 등)에 전달되는 제어명령이라 할 수 있습니다.

- `\n` : New line
- `\t` : Tab
- `\\` : Backslash
- `\"` : 큰 따옴표. 문자열 상수

### 2. 문자와 정수 출력

C 언어에서 정수를 표시하기 위해 가장 자주 사용하는 것은 `char`와 `int`입니다. `char`형과 `int`형은 분명히 다르지만 '부호가 있는 정수형'이라는 점에서 같습니다. 그러니까 해석방법은 같은데 자료의 길이가 8비트, 32비트로 다를 뿐이라 할 수 있습니다. 이런 이유 때문에 `%c`와 `%d` 모두 `int`형을 다루는 것을 원칙으로 합니다.

```c
// 문자 'A'의 ASCII 코드값(65)에 1을 더한 값을 문자로 출력한다.
printf("%c\n", 'A' + 1);

// 문자 'A'의 ASCII 코드값에 1을 더하고 10진수(%d)로 출력한다.
printf("%d\n", 'A' + 1);

// 10진수(정수)를 문자(ASCII)로 출력한다.
printf("%c\n", 65 + 1);
```

정보의 본질(혹은 실제 값)이 달라지는 것이 아니라 단지 **츨력형식을 변경하는 것만으로도 전혀 다른 정보로 인식**될 수 있다는 사실을 알아야 합니다.

그러나 부호가 없는 정수형(unsigned int)을 출력할 때는 `%d` 대신 `%u`를 사용해야 합니다.

```c
// 부호가 있는 32비트 정수로 표현할 수 있는 '범위를 넘어선' 정수를 출력
printf("%d\n", 2147483648);
// 부호가 있는 32비트로 출력하므로 값이 제대로 출력
printf("%u\n", 2147483649);

// 부호가 있는 형식이므로 제대로 출력
printf("%d\n", -1);
// 부호가 없는 형식이므로 전혀 다른 값이 출력
printf("%u\n", -1);
```

32비트 부호가 없는 정수형으로 표현할 수 있는 가장 큰 수는 약 43억 미만입니다. 만일 32비트 범위를 넘는 큰 자료를 다룰 때는 표현범위가 더 넓은 자료형을 사용해야 하는데 이때 사용할만한 자료형으로 `long long int`형이 있습니다.

```c
// 부호가 있는 64비트 정수형 변수 선언 및 정의
long long int lldData = 4294967295LL;

// 64비트 정보를 32비트 형식 문자로 출력
printf("%d\n", lldData);
printf("%u\n", lldData);

// 32비트로는 표현할 수 없는 범위의 정보를 출력
printf("%u\n", lldData + 1);

// 64비트 정보를 64비트 형식 문자(%lld)로 출력
printf("%lld\n", lldData + 1);
```

`%lld`는 몇 비트 응용 프로그램인가애 상관없이 64비트 정수 출력을 지원합니다. 그러므로 몇 십억 대의 큰 정수를 다뤄야 한다면 의도적으로 `long long int` 형식 및 `%lld` 형식 문자를 사용하는 것이 좋습니다.

형식 문자 표현에는 특정 자료형에 대한 출력형식이라는 기본적인 기능 외에 **출력 폼(form)**을 제어하는 기능도 들어있습니다.

```c
// 부호를 붙여서 출력
printf("%+d, %+d\n", 1234, -5678);
// 정수를 8자리로 맞추고 오른쪽 정렬해 출력
printf("%8d\n", 1234);
// 12번 행과 같지만 왼쪽 빈 공간을 모두 0으로 채워서 출력
printf("%08d\n", 1234);
```

### 3. 실수와 지수 출력

실수를 출력할 때는 실수형식 출력과 지수형식 출력을 구분할 수 있습니다. 다만 둘 중에 어떤 형식을 취하든 정수처럼 표현의 범위가 달라지거나 부호개념이 사라지는 경우는 없습니다. 단지 표현형식(`%f` 혹은 `%e`)만 다를 뿐입니다.

```c
// float 형식을 실수 형식으로 출력
printf("%f\n", 123.456F);

// double 형식을 실수 형식으로 출력
printf("%f\n", 123.456);
printf("%lf\n", 123.456);
```

`%f`와 `%lf`는 각각 `float`와 `double`에 해당하는 형식 문자입니다. 그러나 `printf()` 함수에서는 둘을 구별하지 않고 `%f`로 통일해서 사용해도 상관없습니다.

다음은 출력형식을 어떻게 제어할 수 있는지 그 방법을 보인 예제입니다. 주의할 점은 소수점 이하 두 자리만 출력하기로 할 경우 세 번째 자리 숫자를 **반올림**하여 두 번째 자리까지 출력한다는 점입니다.

```c
double dData = 123.456;
printf("%f, %f\n", dData, -123.456);
printf("%.1f\n", dData);
printf("%8d\n", 123);
// 소수점을 포함해 12자리 출력
// 단, 소수점 이하 4번째 자리에서 반올림하고 3자리까지 출력
printf("%12.3f\n", dData);
printf("%012.3f\n", dData);
```

컴퓨터의 부동 소수점 오차로 인한 결함이 발생하지 않을 것이라고 보장할 수 없습니다. 그러므로 **정확한 비교가 필요하다면 무조건 정수를 기반**으로 해야합니다. 즉, 평균점수(실수)보다는 총점(정수)이 더 좋은 선택입니다. 만일 총점도 실수로 표현되는 경우라면 일정수를 곱해서 강제로 정수를 만들면 됩니다.

## `sacnf()` 함수


```c
int scanf(const char *format [, argument]...);
```

- 인자
  - 형식 문자열이 저장된 메모리의 주소
  - 형식 문자열에 대응하는 가변인자들
- 반환값 : 입력할 문자열의 개수

`scanf()` 함수는 `printf()` 함수처럼 형식 문자열을 이용한 사용자 입력을 지원합니다. 따라서 `scanf()` 함수에서도 관련 이론이나 문법은 모두 같습니다. 그러나 한 가지 주의사항이 있는데, 형식 문자에 대응하는 가변인자는 모두 주소라는 점입니다.

### 1. 정수 입력

매개변수로 주소가 전달되고 피호출 함수는 그 주소의 메모리에 정보를 담아주는 방식은 C 언어에서 매우 자주 등장합니다.

예제에서 입력받은 나이는 `int`형 변수인 `nAge`에 저장하도록 헸는데, `scanf()` 함수를 호출할 때 이름이 `nAge` 변수의 주소를 의미하는 `&nAge`가 인수로 사용되었음을 주의합니다.

```c
#include <stdio.h>

int main(void)
{
    int nAge = 0;

    printf("나이를 입력하세요. : ");
    scanf("%d", &nAge);

    printf("당신의 나이는 %d세 입니다.\n", nAge);
    return 0;
}
```

사용자가 입력한 정보를 제대로 해석할 수 없으면 `scanf()` 함수는 인수로 전달된 주소로 식별되는 메모리에 아무것도 담아주지 않습니다.

### 2. 두 정수의 입력 및 구분

```c
#include <stdio.h>

int main(void)
{
    int x = 0, y = 0;

    printf("두 정수를 입력하세요. : ");
    scanf("%d%d", &x, &y);

    printf("두 수의 합은 %d 입니다.\n", x + y);
    return 0;
}
```

`scanf()` 함수는 같은 형식 문자 두 개가 연이어 붙어 있으면 빈칸, tab 키, enter 키(개행문자) 입력으로 각 형식 문자에 대한 입력을 구별합니다. 그러나 다른 형식으로 이어붙이면 굳이 입력의 구분이 없더라도 "3A4"와 같은 입력을 인식할 수 있습니다.

참고로 빈칸(공백문자), Tab(`\t`), 개행문자(`\n`) 등을 화이트 스페이스(white space)라고 부릅니다.

### 3. 문자 입력

`scanf()` 함수를 이용하여 문자를 입력받으려면 형식 문자 `%c`를 이용하면 됩니다.

### 4. 문자열 입력

형식 문자 `%s`를 이용하면 `scanf()` 함수도 `gets()` 함수처럼 문자열을 입력받을 수 있습니다.

```c
#include <stdio.h>

int main(void)
{
    // 문자열을 저장하기 위한 배열 선언 및 정의
    char szBuffer[32] = {0};

    // 사용자가 입력한 문자열을 배열에 저장하고 출력
    scanf("%s", szBuffer);
    printf("%s\n", szBuffer);
    return 0;
}
```

`%s` 형식만으로는 공백문자를 포함한 문자열을 입력받을 수 없습니다. 일반적으로 공백문자를 포함한 문자열 입력은 `gets()` 함수를 이용합니다.

```c
#include <stdio.h>

int main(void)
{
    int userAge = 0;
    char userName[32] = {0};

    printf("나이를 입력하세요. : ");
    scanf("%d", &userAge);

    printf("이름을 입력하세요. : ");
    gets(userName);

    printf("당신의 나이는 %d살이고 이름은 '%s' 입니다.\n", userAge, userName);
    return 0;
}
```

`scanf()` 함수호출 시 사용자 입력의 완료를 의미하는 Enter 키 입력(개행문자)이 버퍼에 남기 때문입니다. `gets()` 함수는 입력 버퍼에 들어있는 개행문자를 '사용자 입력의 끝'으로 인식했기 때문에 입력을 완료합니다.

```c
scanf("%d%*c", &userAge);
```

`scanf()` 함수의 형식 문자열을 구성하여 해결할 수 있습니다. `%*c`라는 형식 문자가 추가된 형태인데, 이것은 문자 하나를 입력 버퍼에서 읽어온 후 그냥 버린다는 의미입니다. 따라서 나이(정수)와 함께 입력한 개행문자를 버퍼에서 꺼내어 버립니다. `%` 기호와 형식 문자 사이에 위치한 별표(`*`)는 '버림'을 의미합니다.