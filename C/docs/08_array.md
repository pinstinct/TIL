# 배열

배열(array)은 **형식이 같은 자료 여러 개가 모여 새로운 하나를 이룬 형식**입니다. 배열이 기존 변수와 가장 다른 점 중 하나는 배열의 이름은 변수의 이름과 달리 메모리의 주소라는 사실입니다. 배열의 이름은 배열을 이루고 있는 여러 요소를 대표하는 **첫 번째 요소의 메모리 주소에 부여하는 식별자**입니다.

'배열 연산자'는 **`배열이름[인덱스]`** 형식을 갖는데, 각 배열요소의 인덱스는 0에서부터 전체요소의 개수보다 1작은 범위까지입니다.

```c
#include <stdio.h>

int main(void)
{
    int aList[5] = {0};
    int i = 0;

    for (i = 0; i < 5; ++i)
        scanf("%d", &aList[i]);

    for (i = 0; i < 5; ++i)
        printf("%d\n", aList[i]);

    return 0;
}
```
`int aList[5]` 코드는 요소의 자료형이 `int`형이고 개수가 5개인 배열의 선언 및 정의입니다. 이 코드로 변수 다섯 개가 한번에 선언 및 정의 됩니다. 그리고 `aList`는 변수가 아니라 **0번 요소의 주소**입니다. 즉 `&aList[0]`입니다.

## 1차원 배열의 기본 문법

문법적으로 한 가지 알아야 할 것은 배열 연산을 통해 배열 요소에 접근하는데, 이 배열연산의 결과가 `l-value`가 될 수 있습니다. 즉, 변수가 될 수 있다는 말입니다.

```c
#include <stdio.h>

int main(void)
{
    int aList[5] = {10, 20, 30, 40, 50};
    int i = 0;

    for (i = 0; i < 5; ++i)
        printf("%d\t", aList[i]);
    putchar('\n');

    // 배열 요소의 값을 변경
    aList[0] = 100;
    aList[3] = 200;

    for (i = 0; i < 5; ++i)
        printf("%d\t", aList[i]);
    putchar('\n');

    return 0;
}
```

## 최대값/최소값

최대값 구하기는 3항 연산자, `if`문을 배울 때도 다뤘습니다. 이제 거기에 배열도 추가하려 합니다.

```c
#include <stdio.h>

int main(void)
{
    int aList[5] = {30, 10, 40, 20, 50};
    int i = 0, nMax = aList[0];  // 배열의 첫 번째 요소를 최대값으로 설정

    // 두 번째 요소(i = 1)부터 마지막 요소까지 비교
    for (i = 1; i < 5; ++i)
    {
        if (aList[i] > nMax)
            nMax = aList[i];
    }

    for (i = 0; i < 5; ++i)
        printf("%d\t", aList[i]);
    putchar('\n');

    printf("MAX: %d\n", nMax);
    return 0;
}
```
서바이벌 방식(=순차검색, sequential search)으로 최대값을 구했습니다.

[실습문제](../code/08/01.c)

[실습문제](../code/08/02.c)

## 문자의 배열

문자열의 실체는 `char`형 배열입니다. 따라서 문자열을 다룬다는 말은 배열을 다룬다는 것으로 생각해야 합니다. 그리고 문자열의 끝은 **`\0`(NULL 문자)**입니다. 문자열을 저장할 메모리의 크기를 계산할 때, 실수로 `\0` 저장될 곤강을 깜빡 해버리는 경우가 자주 발생하니 주의합니다.

### 1. 문자열의 기본 구조

다음 예제는 문자열의 본질이 배열임을 설명하고, **배열의 주소를 저장하기 위한 포인터 변수**의 선언에 대해서 다룹니다.

```c
#include <stdio.h>

int main(void)
{
    // 1. 배열 각 요소의 값을 하나씩 기술하는 방식으로 초기화
    int aList[5] = {30, 40, 10, 50, 20};
    char szBuffer[6] = {'H', 'e', 'l', 'l', 'o', '\0'};

    // 2. 문자열 형태로 문자집합을 기술하는 방식으로 배열 초기화
    char szData[8] = {"Hello"};

    // 3. 문자열 상수를 가리키는 포인터 변수 선언 및 초기화
    char *pszBuffer = "Hello";

    // 문자열은 모두 같은 형식으로 출력
    puts(szBuffer);
    puts(szData);
    puts(pszBuffer);
    return 0;
}
```
문자열 배열을 선언하는 가장 보편적인 예는 2번 입니다. 그러나 내부적으로 뜯어보면 1번처럼 됩니다. 보편적인 방법인 2번은 `NULL` 문자와 같은 초기값들을 생략한 표현입니다. 또한, 2번에서 8개 중 6개만 초기값을 정의했으므로 별도로 기술하지 않은 요소는 `0`으로 초기화 됩니다.

### 2. 문자열의 끝이 `\0`인 이유

```c
#include <stdio.h>

int main(void)
{
    char szBuffer[32] = {0};
    int nLength = 0;

    printf("Input your name : ");
    gets(szBuffer);

    while (szBuffer[nLength] != '\0')
        nLength++;

    printf("Your name is %s(%d)\n", szBuffer, nLength);
    return 0;
}
```
이 방식으로 문자열의 길이를 측정할 때, 배열요소 안에 `\0`이 들어있지 않다면 무한루프가 발생합니다.

사용자가 문자열을 입력하면 32바이트 중 일부가 사용되어 문자열에 저장될 것입니다. 그리고 **전체 배열 메모리에서 `NULL` 문자를 중심으로 왼쪽은 사용된 영역이고 오른쪽은 사용되지 않은 영역**으로 나뉩니다. 프로그래머가 기술해야 할 배열은 늘 고정입니다. 하지만 사용자의 입력은 늘 가변입니다. 이 둘을 하나로 겹쳤을 때 **`NULL` 문자는 구분자**가 되어줍니다.

## 다차원 배열

1차원 배열은 1차원 선형 구조입니다. 다시 1차원 선형 구조를 여러 겹으로 쌓으면 2차원 면 구조입니다. 지금부터 2차원 혹은 3차원 구조의 배열을 다룰 텐데, 이런 배열들을 다차원 배열이라고 부릅니다. 다차원 배열은 메모리의 실제모습과 상관없이 논리적인 구조가 2차원 혹은 3차원인 배열을 의미합니다. 즉, 자료의 접근방법에 한정되는 것입니다.

### 1. 2차원 배열의 기본 문법

2차원 배열은 행(row)과 열(column)로 구성된 2차원 구조입니다. 2차원 배열을 선언할 때는 `자료형 배열이름[행][열];` 형식으로 기술합니다.

```c
#include <stdio.h>

int main(void)
{
    int aList[3][4] = {
        {10, 20, 30, 40},
        {50, 60, 70, 80},
        {90, 100, 110, 120}
    };
    int i, j;

    for (i = 0; i < 3; ++i)
    {
        for (j = 0; j < 4; ++j)
        {
            printf("%d\t", aList[i][j]);
        }
        putchar('\n');
    }
    return 0;
}
```
2차원 배열에 대해 배열연산을 한 번만 수행하면 이는 **주소**를 의미하는 r-value입니다. 예를 들어 `aList[1]`은 1번 행 전체를 의미하는 '주소상수'입니다.


[실습문제](../code/08/03.c)


### 2. 3차원 배열

2차원 배열이 개념적으로 행과 열의 구성인데, 3차원 배열은 여기에 면(plane)을 더해 3차원을 이룹니다.

```c
#include <stdio.h>

int main(void)
{
    int aList[4][2][3] = {0};
    int i, j, k, nCounter = 0;
    for (i = 0; i < 4; ++i)
    {
        // 면
        printf("Plane number : %d\n", i);
        for (j = 0; j < 2; ++j)
        {
            // 행
            for (k = 0; k < 3; ++k)
            {
                // 열
                aList[i][j][k] = ++nCounter;
                printf("%d\t", aList[i][j][k]);
            }
            putchar('\n');
        }
        putchar('\n\n');
    }
    return 0;
}
```
2차원 배열이 여러번 출력된 형태라는 느낌을 받을 수 있습니다. 실제로 3차원 배열처리는 2차원 배열 여러 개를 다루는 방법으로 코드를 작성합니다.


## 연습문제

[문제 01](../code/08/04.c)

[문제 02](../code/08/05.c)
