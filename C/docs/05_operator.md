# 연산자 - 응용

## `sizeof` 연산자

피연산자의 **자료형**에 대한 연산입니다. `sizeof(5)`라는 연산은 정수 5를 말하는 것이 아니라, `sizeof(int)` 연산을 의미합니다. int형의 바이트 단위 메모리 크기가 4바이트이므로 연산의 결과는 4입니다.

```c
printf("%d", sizeof('A'));
```

컴파일러가 컴파일타임에 수행하는 연산자입니다. 따라서 아무리 많이 사용하더라도 프로그램의 수행능력이 떨어지는 일이 없습니다.

## 관계 연산자

상등/부등, 비교 연산자로 분류할 수 있으며, **두 피연산자의 값을 비교해 참(True, 1) 혹은 거짓(False, 0)의 결과를 내는 연산자**입니다.

- 상등연산: `a == b`
- 부등연산: `a != b`
- 비교연산: `a < b`, `a > b`, `a >= b`, `a <=b`

정확한 값을 알 수 없는 임의의 두 숫자가 같은 숫자인지 아닌지 사칙연산으로 알아내려면, 뺄셈을 이용하면 됩니다. 뺄셈 연산 결과가 0이면 두 수가 얼마인지 몰라도 같다는 사실은 명백합니다. 비교 관계 연산자도 내부적으로 뺄셈을 한다고 보면 됩니다.

```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", 300 == 299.99999F);
    printf("%d\n", 300 == 299.99999);
    return 0;
}
```
부동소수점 오차 때문에 맞는 결과입니다. 그러므로 **정수와 실수를 비교하는 관계연산은 바람직하지 않습니다**.

## 논리 연산자

논리 연산자는 **참/거짓으로 결론 내릴 수 있는 두 대상을 피연산자**로 사용합니다. 가장 흔한 대상으로는 관계 연산식이 있습니다. 다시 관계 연산식의 피연산자로 산술 연산식이 올 수도 있습니다. 그리고 이렇게 완성된 논리식을 보통 **조건식**이라고 부릅니다.

### 1. 논리합(OR)과 논리곱(AND)

C 언어에서 논리합(OR)을 의미하는 연산자는 `||` 입니다.

```c
#include <stdio.h>

int main(void)
{
    int nInput = 0, bResult = 0;

    scanf("%d", &nInput);
    bResult = nInput < 4 || nInput >= 60;
    printf("Result: %d (1:True, 0:False)\n", bResult);

    return 0;
}
```
**논리합**으로 여러 관계식을 결합하면 그중 어떤 것이라도 **하나만 만족하면 전체 논리식의 결과는 참**입니다.

- 논리 연산은 왼쪽에서 오른쪽으로 진행한다.
- 경우에 따라 나중에 수행될 연산을 수행하지 않고도 전체 결과를 확정할 수 있다.
  - OR 논리식은 조건에 만족하면 이후 연산을 생략한다.
  - AND 논리식은 조건에 만족하지 않으면 이후 연산은 생략한다.

하지 않아도 될 연산을 생략하여 논리식의 효율을 꾀하는 것을 **쇼트서킷(short circuit)**이라 합니다.

C 언어에서 논리곱(AND)을 의미하는 연산자는 `&&` 입니다. 모든 조건이 다 참이라야 최종 결과도 참입니다.

```c
#include <stdio.h>

int main(void)
{
    int nInput = 0, bResult = 0;

    scanf("%d", &nInput);
    bResult = 3 < nInput < 20;
    printf("Result: %d (1:True, 0:False)\n", bResult);

    return 0;
}
```
위의 예제는 흔히 착각하기 쉬운 예제입니다. 3초과 20미만이라는 조건식을 위와 같이 정의하는 경우가 종종 발생합니다. 가장 먼저 수행하는 연산은 `3 < nInput` 관계연산입니다. 이 연산의 결과는 정수 `1` 또는 `0`입니다. 따라서 이어지는 연산은 `1 < 20`이나 `0 < 20`일 수 밖에 없으므로 늘 참(1)입니다. 결국 어떤 숫자를 입력하더라도 결과는 늘 참이 되는 **논리오류가 발생**합니다. 그러므로 어떤 정수의 시작과 끝을 지정할 때는 다음처럼 반드시 **두 번의 관계식을 조합**해 기술합니다.

```c
nInput > 3 && nInput < 20
```

### 2. 부정

C 언어에서 **부정(NOT)**을 의미하는 연산자는 `!` 입니다. 부정은 단항 연산자이며, 우선순위도 높습니다.

## 조건 연산자(삼항 연산자)

조건 연산자는 C 언어의 유일한 삼항 연산자입니다.

```c
조건식 ? A : B
```
조건식이 참이면 A를 선택하고, 그렇지 않으면(거짓이면) B를 선택합니다. 조건식은 대부분 관계 연산식이나 논리 연산식이며 결과에 따른 선택의 대상은 구문이 아니라 '항'입니다. 따라서 보통 변수나 상수입니다. 만일 선택 대상 피연산자가 연산식이면 반드시 괄호로 묶어야 합니다.

```c
#include <stdio.h>

int main(void)
{
    int nInput = 0, bResult = 0;
    scanf("%d", &nInput);

    // 에러 발생
    // nInput <= 10 ? bResult = 10 : bResult = 20;
    // printf("%d\n", bResult);

    nInput <= 10 ? (bResult = 10) : (bResult = 20);
    printf("%d\n", bResult);

    return 0;
}
```

#### 프로그래밍 기본요소: 분류와 선택

```c
#include <stdio.h>

int main(void)
{
    int input = 0;
    printf("키를 입력하세요. : ");
    scanf("%d", &input);
    printf("결과: %s\n", input >= 150 ? "합격" : "불합격");
    return 0;
}
```

### 1. 최대값 구하기

#### 토너먼트 방식

변수 A, B, C를 다음과 같은 순서로 연산하여 최대값을 구할 수 있습니다.

1. A와 B를 비교하여 둘 중 더 큰 수 하나를 선택한다.
2. 1번 과정에서 선택한 값과 C를 비교하여 더 큰 수 하나를 선택한다.
3. 2번 과정에서 선택한 값을 최대값으로 확정한다.

#### 프로그래밍 기본 요소: 최대값 구하기 (토너먼트 방식)

```c
#include <stdio.h>

int main(void)
{
    int nMax = 0;
    int a, b, c;
    scanf("%d %d %d", &a, &b, &c);
    a > b ? (nMax = a) : (nMax = b);
    nMax > c ? nMax : (nMax = c);

    printf("MAX : %d\n", nMax);
    return 0;
}
```

#### 서바이벌 방식

사용자로부터 정수 셋을 차례로 입력받아 서바이벌 방식으로 최대값을 구하는 예제입니다. 이 예제의 핵심은 사용자 입력 직후 매번 최대값을 다시 계산한다는 것입니다.

```c
#include <stdio.h>

int main(void)
{
    int nMax = 0, nInput = 0;

    // 처음 입력받은 값은 일단 최대값
    scanf("%d", &nInput);
    nMax = nInput;

    // 현재까지 최대값과 사용자가 입력한 값을 비교해 새로운 최대값 결정
    scanf("%d", &nInput);
    nMax = nInput > nMax ? nInput : nMax;

    // 같은 논리를 반복해 최종 최대값 결정
    scanf("%d", &nInput);
    nMax = nInput > nMax ? nInput : nMax;

    printf("MAX : %d\n", nMax);
    return 0;
}
```
유지보수하기가 토너먼트 방식보다 유리합니다. 만일 사용자로부터 입력받는 정수의 개수가 30개로 늘어난다고 하더라도 두 번째 요소를 단순히 반복하는 것만으로 쉽게 유지보수할 수 있습니다. 그러나 토너먼트 방식을 채택했다면 코드의 논리구조를 변경하기가 상대적으로 더 어렵습니다.

### 2. 최대값 구하기 방식 비교

같은 결과를 얻기까지 비교 횟수가 가장 적은 알고리즘이 더 성능이 우수합니다.

- 비교 횟수: 무승부
- 유지보수 및 확장성: 서바이벌 방식 승
- 메모리 사용량: 서바이벌 방식 압도적 우세